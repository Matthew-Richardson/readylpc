<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CodeRED Incident Shapefile Export (NAD83 4269)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 980px; margin: 40px auto; padding: 0 16px; }
    h1 { margin: 0 0 12px; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: end; }
    label { display:block; font-weight: 650; margin-bottom: 6px; }
    select, input, button { padding: 10px 12px; font-size: 16px; }
    button { cursor:pointer; }
    select { min-width: 340px; max-width: 100%; }
    input { min-width: 260px; }
    .status { margin-top: 12px; white-space: pre-wrap; line-height: 1.35; }
    .small { color:#555; font-size: 13px; margin-top: 10px; }
    .pill { display:inline-block; padding:2px 10px; border:1px solid #ddd; border-radius:999px; font-size:12px; margin-left:8px; color:#444; vertical-align: middle; }
    .muted { color:#666; }
    .divider { height: 1px; background: #eee; margin: 12px 0; }
    .danger { color:#8a1f11; }
    .ok { color:#0a7; }
    .warn { color:#b45309; }
    code { background:#f7f7f7; padding:1px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <h1>
    CodeRED Incident Shapefile Export
    <span class="pill">Download as NAD83 (WKID 4269)</span>
  </h1>

  <div class="card">
    <div class="row">
      <div>
        <label for="filter">Filter incidents</label>
        <input id="filter" type="text" placeholder="Type to filter…" />
      </div>

      <div>
        <label for="incident">Incident</label>
        <select id="incident"></select>
      </div>

      <button id="previewBtn">Preview Count</button>
      <button id="exportBtn">Export Shapefile (.zip)</button>
    </div>

    <div class="status" id="status"></div>

    <div class="divider"></div>

    <div class="small">
      Source layer: <span class="muted">LPC_Evac_Zones_View (FeatureServer/0)</span><br/>
      Filter field: <code>incident</code><br/>
      Requesting output coords: <code>outSR=4269</code> (NAD83)<br/>
      <span class="muted">Debug: this page validates the ZIP signature (“PK”) before downloading.</span>
    </div>
  </div>

  <!-- Libraries (client-side only) -->
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://unpkg.com/@mapbox/shp-write@0.4.3/shpwrite.js"></script>

  <script>
    // === CONFIG ===
    const FEATURE_LAYER =
      "https://services2.arcgis.com/ilLrLpXfElYxSy9y/ArcGIS/rest/services/LPC_Evac_Zones_View/FeatureServer/0";
    const INCIDENT_FIELD = "incident";
    const OUT_SR = 4269;

    // Browser stability guardrails
    const HARD_STOP_FEATURES = 50000;   // keep browser export stable
    const DEFAULT_FALLBACK_PAGE = 2000; // typical ArcGIS maxRecordCount

    // === UI HOOKS ===
    const incidentEl = document.getElementById('incident');
    const filterEl   = document.getElementById('filter');
    const statusEl   = document.getElementById('status');
    const exportBtn  = document.getElementById('exportBtn');
    const previewBtn = document.getElementById('previewBtn');

    let allIncidents = [];

    function setStatus(msg, cls) {
      statusEl.textContent = msg;
      statusEl.classList.remove("danger", "ok", "warn");
      if (cls) statusEl.classList.add(cls);
    }

    function escapeSqlString(v) {
      return String(v).replace(/'/g, "''");
    }

    function safeBaseName(name) {
      const cleaned = String(name || "")
        .trim()
        .replace(/[^\w\-]+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 40);
      return cleaned || "incident";
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Request failed (${res.status})`);
      const data = await res.json();
      if (data && data.error) {
        const msg = data.error.message || "ArcGIS error";
        const details = Array.isArray(data.error.details) ? ("\n" + data.error.details.join("\n")) : "";
        throw new Error(`${msg}${details}`);
      }
      return data;
    }

    async function getLayerInfo() {
      return await fetchJson(`${FEATURE_LAYER}?f=pjson`);
    }

    async function loadIncidents() {
      setStatus("Loading incidents…");

      const url =
        `${FEATURE_LAYER}/query` +
        `?where=1%3D1` +
        `&outFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&returnDistinctValues=true` +
        `&returnGeometry=false` +
        `&orderByFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&f=pjson`;

      const data = await fetchJson(url);

      const vals = [];
      (data.features || []).forEach(f => {
        const v = f?.attributes?.[INCIDENT_FIELD];
        if (v !== null && v !== undefined && String(v).trim() !== "") vals.push(String(v).trim());
      });

      allIncidents = [...new Set(vals)].sort((a,b)=>a.localeCompare(b));
      renderIncidents("");

      setStatus(allIncidents.length
        ? `Loaded ${allIncidents.length} incidents.`
        : "No incidents found.", allIncidents.length ? "ok" : "warn");
    }

    function renderIncidents(filterText) {
      const ft = (filterText || "").trim().toLowerCase();
      const list = ft
        ? allIncidents.filter(x => x.toLowerCase().includes(ft))
        : allIncidents;

      incidentEl.innerHTML = list.map(x => `<option value="${encodeURIComponent(x)}">${x}</option>`).join("");
      if (!list.length) incidentEl.innerHTML = `<option value="">No matches</option>`;
    }

    async function fetchObjectIds(where) {
      const url =
        `${FEATURE_LAYER}/query` +
        `?where=${encodeURIComponent(where)}` +
        `&returnIdsOnly=true` +
        `&f=pjson`;
      const data = await fetchJson(url);
      return (data.objectIds || []).map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
    }

    async function fetchGeoJsonByObjectIds(objectIds, outFields="*") {
      const url =
        `${FEATURE_LAYER}/query` +
        `?objectIds=${encodeURIComponent(objectIds.join(","))}` +
        `&outFields=${encodeURIComponent(outFields)}` +
        `&returnGeometry=true` +
        `&outSR=${OUT_SR}` +
        `&f=geojson`;
      return await fetchJson(url);
    }

    function sanitizeForDbf(fc) {
      fc.features = (fc.features || []).filter(f =>
        f && f.geometry && f.geometry.type && f.geometry.coordinates !== undefined && f.geometry.coordinates !== null
      );

      for (const f of fc.features) {
        const p = f.properties || {};
        for (const k of Object.keys(p)) {
          const v = p[k];
          if (v === null || v === undefined) continue;
          const t = typeof v;
          if (t === "string" || t === "number" || t === "boolean") continue;
          if (v instanceof Date) p[k] = v.toISOString();
          else p[k] = JSON.stringify(v);
        }
        f.properties = p;
      }
    }

    function binaryStringToUint8Array(str) {
      // Treat as Latin-1 binary string
      const out = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) out[i] = str.charCodeAt(i) & 0xff;
      return out;
    }

    async function toZipBytes(zipOut) {
      // Some builds return a Promise
      if (zipOut && typeof zipOut.then === "function") zipOut = await zipOut;

      if (zipOut instanceof ArrayBuffer) return new Uint8Array(zipOut);

      // Typed array (Uint8Array, etc.)
      if (zipOut && zipOut.buffer instanceof ArrayBuffer && typeof zipOut.byteLength === "number") {
        return new Uint8Array(zipOut.buffer, zipOut.byteOffset || 0, zipOut.byteLength);
      }

      // Binary string (rare but real)
      if (typeof zipOut === "string") {
        return binaryStringToUint8Array(zipOut);
      }

      throw new Error(`Unexpected zip() return type: ${zipOut?.constructor?.name || typeof zipOut}`);
    }

    function isZipSignature(u8) {
      // ZIP files start with "PK" => 0x50 0x4B
      return u8 && u8.length >= 2 && u8[0] === 0x50 && u8[1] === 0x4B;
    }

    async function previewCount() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;
      setStatus(`Counting features for:\n"${incident}"\n\nFetching objectIds…`);

      const objectIds = await fetchObjectIds(where);
      setStatus(`"${incident}"\nFeature count: ${objectIds.length}`, "ok");
    }

    async function exportShapefile() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      exportBtn.disabled = true;
      previewBtn.disabled = true;

      try {
        const layerInfo = await getLayerInfo();
        const layerWkid = layerInfo?.extent?.spatialReference?.wkid ?? layerInfo?.sourceSpatialReference?.wkid;
        const pageSize = Number(layerInfo.maxRecordCount) || DEFAULT_FALLBACK_PAGE;

        const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;

        setStatus(
          `Layer SR (reported): ${layerWkid ?? "unknown"}\n` +
          `Requesting outSR: ${OUT_SR}\n\n` +
          `Preparing export for:\n"${incident}"\n\nFetching objectIds…`
        );

        const objectIds = await fetchObjectIds(where);

        if (!objectIds.length) {
          setStatus(`No features found for:\n"${incident}"`, "warn");
          return;
        }

        if (objectIds.length > HARD_STOP_FEATURES) {
          setStatus(
            `Too many features for a browser-only export.\n\n` +
            `Count: ${objectIds.length}\n` +
            `Limit: ${HARD_STOP_FEATURES}\n\n` +
            `Tip: If you truly need exports this large, you’ll need a server endpoint to stream the ZIP.`,
            "warn"
          );
          return;
        }

        setStatus(
          `Found ${objectIds.length} features.\n` +
          `Downloading GeoJSON in batches of ${pageSize} (outSR=${OUT_SR})…`
        );

        const combined = { type: "FeatureCollection", features: [] };

        for (let i = 0; i < objectIds.length; i += pageSize) {
          const batch = objectIds.slice(i, i + pageSize);
          setStatus(`Downloading… ${Math.min(i + pageSize, objectIds.length)} / ${objectIds.length}`);
          const fc = await fetchGeoJsonByObjectIds(batch, "*");
          if (fc?.features?.length) combined.features.push(...fc.features);
        }

        setStatus(`Downloaded ${combined.features.length} features.\nSanitizing for shapefile…`);
        sanitizeForDbf(combined);

        if (!combined.features.length) {
          setStatus(`No valid geometries returned for:\n"${incident}"`, "warn");
          return;
        }

        const base = safeBaseName(incident);

        setStatus(`Building shapefile ZIP in browser…`);
        const zipOut = shpwrite.zip(combined, {
          folder: base,
          types: { point: `${base}_pts`, polygon: `${base}_poly`, line: `${base}_line` }
        });

        const zipU8 = await toZipBytes(zipOut);

        const sigOk = isZipSignature(zipU8);
        setStatus(
          `ZIP built.\n` +
          `Bytes: ${zipU8.byteLength.toLocaleString()}\n` +
          `Signature: ${sigOk ? "PK (valid)" : "NOT PK (invalid)"}\n` +
          `Downloading…`,
          sigOk ? "ok" : "danger"
        );

        if (!sigOk) {
          throw new Error("ZIP signature is not 'PK' — output is not a valid ZIP. (Usually caused by shapefile/DBF encoding issues.)");
        }

        const blob = new Blob([zipU8], { type: "application/zip" });
        saveAs(blob, `${base}_NAD83_4269.zip`);

        setStatus(`Done.\nSaved: ${base}_NAD83_4269.zip`, "ok");
      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        setStatus(
          `Error:\n${msg}\n\n` +
          `If downloads work but ZIP fails validation, the issue is typically a shapefile/DBF constraint (field types/lengths) from the source data.\n` +
          `This page already stringifies complex values, but a few edge cases can still break older DBF writers.`,
          "danger"
        );
      } finally {
        exportBtn.disabled = false;
        previewBtn.disabled = false;
      }
    }

    // Events
    filterEl.addEventListener('input', () => renderIncidents(filterEl.value));
    previewBtn.addEventListener('click', () => previewCount());
    exportBtn.addEventListener('click', () => exportShapefile());

    // Init
    loadIncidents().catch(err => {
      setStatus(`Error loading incidents:\n${err.message || err}`, "danger");
    });
  </script>
</body>
</html>
