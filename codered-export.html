<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CodeRED Incident Shapefile Export (NAD83 4269)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 980px; margin: 40px auto; padding: 0 16px; }
    h1 { margin: 0 0 12px; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: end; }
    label { display:block; font-weight: 650; margin-bottom: 6px; }
    select, input, button { padding: 10px 12px; font-size: 16px; }
    button { cursor:pointer; }
    select { min-width: 340px; max-width: 100%; }
    input { min-width: 260px; }
    .status { margin-top: 12px; white-space: pre-wrap; line-height: 1.35; }
    .small { color:#555; font-size: 13px; margin-top: 10px; }
    .pill { display:inline-block; padding:2px 10px; border:1px solid #ddd; border-radius:999px; font-size:12px; margin-left:8px; color:#444; vertical-align: middle; }
    .muted { color:#666; }
    .divider { height: 1px; background: #eee; margin: 12px 0; }
    .danger { color:#8a1f11; }
    .ok { color:#0a7; }
    .warn { color:#b45309; }
    code { background:#f7f7f7; padding:1px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <h1>
    CodeRED Incident Shapefile Export
    <span class="pill">Download as NAD83 (WKID 4269)</span>
  </h1>

  <div class="card">
    <div class="row">
      <div>
        <label for="filter">Filter incidents</label>
        <input id="filter" type="text" placeholder="Type to filter…" />
      </div>

      <div>
        <label for="incident">Incident</label>
        <select id="incident"></select>
      </div>

      <button id="previewBtn">Preview Count</button>
      <button id="exportBtn">Export Shapefile (.zip)</button>
    </div>

    <div class="status" id="status"></div>

    <div class="divider"></div>

    <div class="small">
      Source layer: <span class="muted">LPC_Evac_Zones_View (FeatureServer/0)</span><br/>
      Filter field: <code>incident</code><br/>
      Requesting output coords: <code>outSR=4269</code> (NAD83)<br/>
      <span class="muted">Exporter: shapefile-write + JSZip (client-side)</span>
    </div>
  </div>

  <!-- Download helper -->
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- JSZip -->
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- shapefile-write (UMD build exposes `shpwrite` on window in some builds; we’ll also support `shapefileWrite`) -->
  <script src="https://unpkg.com/shapefile-write@0.4.3/shapefile-write.js"></script>

  <script>
    // === CONFIG ===
    const FEATURE_LAYER =
      "https://services2.arcgis.com/ilLrLpXfElYxSy9y/ArcGIS/rest/services/LPC_Evac_Zones_View/FeatureServer/0";
    const INCIDENT_FIELD = "incident";
    const OUT_SR = 4269;

    const HARD_STOP_FEATURES = 50000;
    const DEFAULT_FALLBACK_PAGE = 2000;

    const incidentEl = document.getElementById('incident');
    const filterEl   = document.getElementById('filter');
    const statusEl   = document.getElementById('status');
    const exportBtn  = document.getElementById('exportBtn');
    const previewBtn = document.getElementById('previewBtn');

    let allIncidents = [];

    function setStatus(msg, cls) {
      statusEl.textContent = msg;
      statusEl.classList.remove("danger", "ok", "warn");
      if (cls) statusEl.classList.add(cls);
    }

    function escapeSqlString(v) { return String(v).replace(/'/g, "''"); }

    function safeBaseName(name) {
      const cleaned = String(name || "")
        .trim()
        .replace(/[^\w\-]+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 40);
      return cleaned || "incident";
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Request failed (${res.status})`);
      const data = await res.json();
      if (data && data.error) {
        const msg = data.error.message || "ArcGIS error";
        const details = Array.isArray(data.error.details) ? ("\n" + data.error.details.join("\n")) : "";
        throw new Error(`${msg}${details}`);
      }
      return data;
    }

    async function getLayerInfo() {
      return await fetchJson(`${FEATURE_LAYER}?f=pjson`);
    }

    async function loadIncidents() {
      setStatus("Loading incidents…");

      const url =
        `${FEATURE_LAYER}/query` +
        `?where=1%3D1` +
        `&outFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&returnDistinctValues=true` +
        `&returnGeometry=false` +
        `&orderByFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&f=pjson`;

      const data = await fetchJson(url);

      const vals = [];
      (data.features || []).forEach(f => {
        const v = f?.attributes?.[INCIDENT_FIELD];
        if (v !== null && v !== undefined && String(v).trim() !== "") vals.push(String(v).trim());
      });

      allIncidents = [...new Set(vals)].sort((a,b)=>a.localeCompare(b));
      renderIncidents("");

      setStatus(allIncidents.length ? `Loaded ${allIncidents.length} incidents.` : "No incidents found.",
        allIncidents.length ? "ok" : "warn");
    }

    function renderIncidents(filterText) {
      const ft = (filterText || "").trim().toLowerCase();
      const list = ft ? allIncidents.filter(x => x.toLowerCase().includes(ft)) : allIncidents;
      incidentEl.innerHTML = list.map(x => `<option value="${encodeURIComponent(x)}">${x}</option>`).join("");
      if (!list.length) incidentEl.innerHTML = `<option value="">No matches</option>`;
    }

    async function fetchObjectIds(where) {
      const url =
        `${FEATURE_LAYER}/query` +
        `?where=${encodeURIComponent(where)}` +
        `&returnIdsOnly=true` +
        `&f=pjson`;
      const data = await fetchJson(url);
      return (data.objectIds || []).map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
    }

    async function fetchGeoJsonByObjectIds(objectIds, outFields="*") {
      const url =
        `${FEATURE_LAYER}/query` +
        `?objectIds=${encodeURIComponent(objectIds.join(","))}` +
        `&outFields=${encodeURIComponent(outFields)}` +
        `&returnGeometry=true` +
        `&outSR=${OUT_SR}` +
        `&f=geojson`;
      return await fetchJson(url);
    }

    function sanitizeForDbf(fc) {
      fc.features = (fc.features || []).filter(f =>
        f && f.geometry && f.geometry.type && f.geometry.coordinates !== undefined && f.geometry.coordinates !== null
      );

      for (const f of fc.features) {
        const p = f.properties || {};
        for (const k of Object.keys(p)) {
          const v = p[k];
          if (v === null || v === undefined) continue;
          const t = typeof v;
          if (t === "string" || t === "number" || t === "boolean") continue;
          p[k] = (v instanceof Date) ? v.toISOString() : JSON.stringify(v);
        }
        f.properties = p;
      }
    }

    function isZipSignature(u8) {
      return u8 && u8.length >= 2 && u8[0] === 0x50 && u8[1] === 0x4B;
    }

    function getExporter() {
      // shapefile-write UMD variants differ; try common globals
      // - window.shapefileWrite (some builds)
      // - window.shpwrite (others)
      return window.shapefileWrite || window.shpwrite || null;
    }

    async function previewCount() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;
      setStatus(`Counting features for:\n"${incident}"\n\nFetching objectIds…`);

      const objectIds = await fetchObjectIds(where);
      setStatus(`"${incident}"\nFeature count: ${objectIds.length}`, "ok");
    }

    async function exportShapefile() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      exportBtn.disabled = true;
      previewBtn.disabled = true;

      try {
        const exporter = getExporter();
        if (!window.JSZip) throw new Error("JSZip failed to load.");
        if (!exporter) throw new Error("shapefile-write exporter failed to load (check CDN).");

        const layerInfo = await getLayerInfo();
        const layerWkid = layerInfo?.extent?.spatialReference?.wkid ?? layerInfo?.sourceSpatialReference?.wkid;
        const pageSize = Number(layerInfo.maxRecordCount) || DEFAULT_FALLBACK_PAGE;

        const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;

        setStatus(
          `Layer SR (reported): ${layerWkid ?? "unknown"}\n` +
          `Requesting outSR: ${OUT_SR}\n\n` +
          `Preparing export for:\n"${incident}"\n\nFetching objectIds…`
        );

        const objectIds = await fetchObjectIds(where);

        if (!objectIds.length) {
          setStatus(`No features found for:\n"${incident}"`, "warn");
          return;
        }
        if (objectIds.length > HARD_STOP_FEATURES) {
          setStatus(`Too many features (${objectIds.length}) for browser-only export (limit ${HARD_STOP_FEATURES}).`, "warn");
          return;
        }

        setStatus(`Found ${objectIds.length} features.\nDownloading GeoJSON in batches of ${pageSize}…`);

        const combined = { type: "FeatureCollection", features: [] };

        for (let i = 0; i < objectIds.length; i += pageSize) {
          const batch = objectIds.slice(i, i + pageSize);
          setStatus(`Downloading… ${Math.min(i + pageSize, objectIds.length)} / ${objectIds.length}`);
          const fc = await fetchGeoJsonByObjectIds(batch, "*");
          if (fc?.features?.length) combined.features.push(...fc.features);
        }

        setStatus(`Downloaded ${combined.features.length} features.\nSanitizing attributes/geometries…`);
        sanitizeForDbf(combined);

        if (!combined.features.length) {
          setStatus(`No valid geometries returned for:\n"${incident}"`, "warn");
          return;
        }

        const base = safeBaseName(incident);

        setStatus(`Building shapefile ZIP with JSZip…`);

        // shapefile-write API: some builds provide `write(fc, options)` returning a JSZip instance,
        // others provide `download(fc, options)` which triggers download. We want the zip bytes.
        let zip;
        if (typeof exporter.write === "function") {
          zip = exporter.write(combined, { folder: base, types: { point: "points", line: "lines", polygon: "polygons" } });
        } else {
          // Fallback: if only download is available, we can’t validate bytes; try download anyway.
          if (typeof exporter.download === "function") {
            exporter.download(combined, { folder: base, filename: `${base}_NAD83_4269` });
            setStatus(`Download triggered (exporter.download). If you still can’t expand it, tell me your OS + incident.`, "ok");
            return;
          }
          throw new Error("Exporter does not expose write() or download().");
        }

        if (!zip || typeof zip.generateAsync !== "function") {
          throw new Error("Exporter returned an unexpected ZIP object.");
        }

        const u8 = await zip.generateAsync({ type: "uint8array", compression: "DEFLATE" });

        setStatus(`ZIP built.\nBytes: ${u8.byteLength.toLocaleString()}\nSignature: ${isZipSignature(u8) ? "PK (valid)" : "NOT PK (invalid)"}`,
          isZipSignature(u8) ? "ok" : "danger");

        if (!isZipSignature(u8)) {
          throw new Error("ZIP signature is not 'PK' — output is not a valid ZIP.");
        }

        const blob = new Blob([u8], { type: "application/zip" });
        saveAs(blob, `${base}_NAD83_4269.zip`);

        setStatus(`Done.\nSaved: ${base}_NAD83_4269.zip`, "ok");
      } catch (err) {
        console.error(err);
        setStatus(`Error:\n${err.message || err}`, "danger");
      } finally {
        exportBtn.disabled = false;
        previewBtn.disabled = false;
      }
    }

    filterEl.addEventListener('input', () => renderIncidents(filterEl.value));
    previewBtn.addEventListener('click', () => previewCount());
    exportBtn.addEventListener('click', () => exportShapefile());

    loadIncidents().catch(err => setStatus(`Error loading incidents:\n${err.message || err}`, "danger"));
  </script>
</body>
</html>
