<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CodeRED Incident Shapefile Export (NAD83 4269)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 980px; margin: 40px auto; padding: 0 16px; }
    h1 { margin: 0 0 12px; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: end; }
    label { display:block; font-weight: 650; margin-bottom: 6px; }
    select, input, button { padding: 10px 12px; font-size: 16px; }
    button { cursor:pointer; }
    select { min-width: 340px; max-width: 100%; }
    input { min-width: 260px; }
    .status { margin-top: 12px; white-space: pre-wrap; line-height: 1.35; }
    .small { color:#555; font-size: 13px; margin-top: 10px; }
    .pill { display:inline-block; padding:2px 10px; border:1px solid #ddd; border-radius:999px; font-size:12px; margin-left:8px; color:#444; vertical-align: middle; }
    .muted { color:#666; }
    .divider { height: 1px; background: #eee; margin: 12px 0; }
    .danger { color:#8a1f11; }
  </style>
</head>
<body>
  <h1>
    CodeRED Incident Shapefile Export
    <span class="pill">NAD83 (WKID 4269)</span>
  </h1>

  <div class="card">
    <div class="row">
      <div>
        <label for="filter">Filter incidents</label>
        <input id="filter" type="text" placeholder="Type to filter…" />
      </div>

      <div>
        <label for="incident">Incident</label>
        <select id="incident"></select>
      </div>

      <button id="previewBtn">Preview Count</button>
      <button id="exportBtn">Export Shapefile (.zip)</button>
    </div>

    <div class="status" id="status"></div>

    <div class="divider"></div>

    <div class="small">
      Source layer:
      <span class="muted">LPC_Evac_Zones_View (FeatureServer/0)</span><br/>
      Filters by field: <code>incident</code><br/>
      Export is requested from ArcGIS already in NAD83 via: <code>outSR=4269</code>
    </div>
  </div>

  <!-- Client-side download + shapefile ZIP -->
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://unpkg.com/@mapbox/shp-write@0.4.3/shpwrite.js"></script>

  <script>
    // === CONFIG ===
    const FEATURE_LAYER =
      "https://services2.arcgis.com/ilLrLpXfElYxSy9y/ArcGIS/rest/services/LPC_Evac_Zones_View/FeatureServer/0";
    const INCIDENT_FIELD = "incident";
    const OUT_SR = 4269;

    // Browser stability guardrails
    const HARD_STOP_FEATURES = 50000;   // stop huge exports (tab stability)
    const DEFAULT_FALLBACK_PAGE = 2000; // typical ArcGIS maxRecordCount

    // === UI HOOKS ===
    const incidentEl = document.getElementById('incident');
    const filterEl   = document.getElementById('filter');
    const statusEl   = document.getElementById('status');
    const exportBtn  = document.getElementById('exportBtn');
    const previewBtn = document.getElementById('previewBtn');

    let allIncidents = [];

    function setStatus(msg) { statusEl.textContent = msg; }

    function escapeSqlString(v) {
      // ArcGIS SQL string escape for single quotes
      return String(v).replace(/'/g, "''");
    }

    function safeBaseName(name) {
      const cleaned = String(name || "")
        .trim()
        .replace(/[^\w\-]+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 40);
      return cleaned || "incident";
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Request failed (${res.status})`);
      return await res.json();
    }

    async function getLayerInfo() {
      return await fetchJson(`${FEATURE_LAYER}?f=pjson`);
    }

    async function loadIncidents() {
      setStatus("Loading incidents…");

      const url =
        `${FEATURE_LAYER}/query` +
        `?where=1%3D1` +
        `&outFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&returnDistinctValues=true` +
        `&returnGeometry=false` +
        `&orderByFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&f=pjson`;

      const data = await fetchJson(url);

      const vals = [];
      (data.features || []).forEach(f => {
        const v = f?.attributes?.[INCIDENT_FIELD];
        if (v !== null && v !== undefined && String(v).trim() !== "") vals.push(String(v).trim());
      });

      allIncidents = [...new Set(vals)].sort((a,b)=>a.localeCompare(b));
      renderIncidents("");

      setStatus(allIncidents.length
        ? `Loaded ${allIncidents.length} incidents.`
        : "No incidents found.");
    }

    function renderIncidents(filterText) {
      const ft = (filterText || "").trim().toLowerCase();
      const list = ft
        ? allIncidents.filter(x => x.toLowerCase().includes(ft))
        : allIncidents;

      incidentEl.innerHTML = list.map(x => `<option value="${encodeURIComponent(x)}">${x}</option>`).join("");

      if (!list.length) {
        incidentEl.innerHTML = `<option value="">No matches</option>`;
      }
    }

    async function fetchObjectIds(where) {
      const url =
        `${FEATURE_LAYER}/query` +
        `?where=${encodeURIComponent(where)}` +
        `&returnIdsOnly=true` +
        `&f=pjson`;

      const data = await fetchJson(url);
      return (data.objectIds || []).map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
    }

    async function fetchGeoJsonByObjectIds(objectIds, outFields="*") {
      const url =
        `${FEATURE_LAYER}/query` +
        `?objectIds=${encodeURIComponent(objectIds.join(","))}` +
        `&outFields=${encodeURIComponent(outFields)}` +
        `&returnGeometry=true` +
        `&outSR=${OUT_SR}` +
        `&f=geojson`;

      return await fetchJson(url);
    }

    async function previewCount() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;
      setStatus(`Counting features for:\n"${incident}"\n\nFetching objectIds…`);

      const objectIds = await fetchObjectIds(where);
      setStatus(`"${incident}"\nFeature count: ${objectIds.length}`);
    }

    async function exportShapefile() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      exportBtn.disabled = true;
      previewBtn.disabled = true;

      try {
        const layerInfo = await getLayerInfo();
        const pageSize = Number(layerInfo.maxRecordCount) || DEFAULT_FALLBACK_PAGE;

        const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;

        setStatus(`Preparing export for:\n"${incident}"\n\nFetching objectIds…`);
        const objectIds = await fetchObjectIds(where);

        if (!objectIds.length) {
          setStatus(`No features found for:\n"${incident}"`);
          return;
        }

        if (objectIds.length > HARD_STOP_FEATURES) {
          setStatus(
            `Too many features for a browser-only export.\n\n` +
            `Count: ${objectIds.length}\n` +
            `Limit: ${HARD_STOP_FEATURES}\n\n` +
            `Tip: If you truly need exports this large, you’ll want a small server endpoint to stream the ZIP.`
          );
          return;
        }

        setStatus(
          `Found ${objectIds.length} features.\n` +
          `Downloading GeoJSON in batches of ${pageSize}…`
        );

        const combined = { type: "FeatureCollection", features: [] };

        for (let i = 0; i < objectIds.length; i += pageSize) {
          const batch = objectIds.slice(i, i + pageSize);
          setStatus(
            `Downloading… ${Math.min(i + pageSize, objectIds.length)} / ${objectIds.length}\n` +
            `(This may take a minute for large incidents.)`
          );

          const fc = await fetchGeoJsonByObjectIds(batch, "*");
          if (fc?.features?.length) combined.features.push(...fc.features);
        }

        setStatus(
          `Downloaded ${combined.features.length} features.\n` +
          `Building shapefile ZIP (NAD83 / 4269)…`
        );

        const base = safeBaseName(incident);

        // Create ZIP bytes in-memory. shp-write may split by geometry type.
        const zipArrayBuffer = shpwrite.zip(combined, {
          folder: base,
          types: { point: `${base}_pts`, polygon: `${base}_poly`, line: `${base}_line` }
        });

        const blob = new Blob([zipArrayBuffer], { type: "application/zip" });
        saveAs(blob, `${base}_NAD83_4269.zip`);

        setStatus(`Done.\nSaved: ${base}_NAD83_4269.zip`);
      } catch (err) {
        console.error(err);
        const msg = (err && err.message) ? err.message : String(err);
        setStatus(`Error:\n${msg}\n\nIf this looks like a CORS error, the service must allow cross-origin requests from your IIS domain for pure HTML/JS exports to work.`);
        statusEl.classList.add("danger");
      } finally {
        exportBtn.disabled = false;
        previewBtn.disabled = false;
      }
    }

    // Events
    filterEl.addEventListener('input', () => renderIncidents(filterEl.value));
    previewBtn.addEventListener('click', () => previewCount());
    exportBtn.addEventListener('click', () => exportShapefile());

    // Init
    loadIncidents().catch(err => {
      console.error(err);
      setStatus(`Error loading incidents:\n${err.message || err}\n\nIf this is CORS-related, the ArcGIS service must permit your site origin.`);
    });
  </script>
</body>
</html>
