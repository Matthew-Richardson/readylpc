<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CodeRED Incident Shapefile Export (NAD83 4269)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 980px; margin: 40px auto; padding: 0 16px; }
    h1 { margin: 0 0 12px; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: end; }
    label { display:block; font-weight: 650; margin-bottom: 6px; }
    select, input, button { padding: 10px 12px; font-size: 16px; }
    button { cursor:pointer; }
    select { min-width: 340px; max-width: 100%; }
    input { min-width: 260px; }
    .status { margin-top: 12px; white-space: pre-wrap; line-height: 1.35; }
    .small { color:#555; font-size: 13px; margin-top: 10px; }
    .pill { display:inline-block; padding:2px 10px; border:1px solid #ddd; border-radius:999px; font-size:12px; margin-left:8px; color:#444; vertical-align: middle; }
    .muted { color:#666; }
    .divider { height: 1px; background: #eee; margin: 12px 0; }
    .danger { color:#8a1f11; }
    .ok { color:#0a7; }
    .warn { color:#b45309; }
    code { background:#f7f7f7; padding:1px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <h1>
    CodeRED Incident Shapefile Export
    <span class="pill">Download as NAD83 (WKID 4269)</span>
  </h1>

  <div class="card">
    <div class="row">
      <div>
        <label for="filter">Filter incidents</label>
        <input id="filter" type="text" placeholder="Type to filter…" />
      </div>

      <div>
        <label for="incident">Incident</label>
        <select id="incident"></select>
      </div>

      <button id="previewBtn">Preview Count</button>
      <button id="exportBtn">Export Shapefile (.zip)</button>
    </div>

    <div class="status" id="status"></div>

    <div class="divider"></div>

    <div class="small">
      Source layer: <span class="muted">LPC_Evac_Zones_View (FeatureServer/0)</span><br/>
      Filter field: <code>incident</code><br/>
      Requesting output coords from ArcGIS as NAD83 via: <code>outSR=4269</code><br/>
      <span class="muted">This page generates the ZIP bytes properly (JSZip generateAsync when needed).</span>
    </div>
  </div>

  <!-- Download helper -->
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- @mapbox/shp-write UMD bundle -->
  <script src="https://unpkg.com/@mapbox/shp-write@0.4.3/shpwrite.js"></script>

  <script>
    // === CONFIG ===
    const FEATURE_LAYER =
      "https://services2.arcgis.com/ilLrLpXfElYxSy9y/ArcGIS/rest/services/LPC_Evac_Zones_View/FeatureServer/0";
    const INCIDENT_FIELD = "incident";
    const OUT_SR = 4269;

    // Browser stability guardrails
    const HARD_STOP_FEATURES = 50000;
    const DEFAULT_FALLBACK_PAGE = 2000;

    // === UI ===
    const incidentEl = document.getElementById('incident');
    const filterEl   = document.getElementById('filter');
    const statusEl   = document.getElementById('status');
    const exportBtn  = document.getElementById('exportBtn');
    const previewBtn = document.getElementById('previewBtn');

    let allIncidents = [];

    function setStatus(msg, cls) {
      statusEl.textContent = msg;
      statusEl.classList.remove("danger", "ok", "warn");
      if (cls) statusEl.classList.add(cls);
    }

    function escapeSqlString(v) { return String(v).replace(/'/g, "''"); }

    function safeBaseName(name) {
      const cleaned = String(name || "")
        .trim()
        .replace(/[^\w\-]+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 40);
      return cleaned || "incident";
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Request failed (${res.status})`);
      const data = await res.json();
      if (data && data.error) {
        const msg = data.error.message || "ArcGIS error";
        const details = Array.isArray(data.error.details) ? ("\n" + data.error.details.join("\n")) : "";
        throw new Error(`${msg}${details}`);
      }
      return data;
    }

    async function getLayerInfo() {
      return await fetchJson(`${FEATURE_LAYER}?f=pjson`);
    }

    async function loadIncidents() {
      setStatus("Loading incidents…");

      const url =
        `${FEATURE_LAYER}/query` +
        `?where=1%3D1` +
        `&outFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&returnDistinctValues=true` +
        `&returnGeometry=false` +
        `&orderByFields=${encodeURIComponent(INCIDENT_FIELD)}` +
        `&f=pjson`;

      const data = await fetchJson(url);

      const vals = [];
      (data.features || []).forEach(f => {
        const v = f?.attributes?.[INCIDENT_FIELD];
        if (v !== null && v !== undefined && String(v).trim() !== "") vals.push(String(v).trim());
      });

      allIncidents = [...new Set(vals)].sort((a,b)=>a.localeCompare(b));
      renderIncidents("");
      setStatus(allIncidents.length ? `Loaded ${allIncidents.length} incidents.` : "No incidents found.",
        allIncidents.length ? "ok" : "warn");
    }

    function renderIncidents(filterText) {
      const ft = (filterText || "").trim().toLowerCase();
      const list = ft ? allIncidents.filter(x => x.toLowerCase().includes(ft)) : allIncidents;
      incidentEl.innerHTML = list.map(x => `<option value="${encodeURIComponent(x)}">${x}</option>`).join("");
      if (!list.length) incidentEl.innerHTML = `<option value="">No matches</option>`;
    }

    async function fetchObjectIds(where) {
      const url =
        `${FEATURE_LAYER}/query` +
        `?where=${encodeURIComponent(where)}` +
        `&returnIdsOnly=true` +
        `&f=pjson`;
      const data = await fetchJson(url);
      return (data.objectIds || []).map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
    }

    async function fetchGeoJsonByObjectIds(objectIds, outFields="*") {
      // Ask ArcGIS to return NAD83 coords directly:
      const url =
        `${FEATURE_LAYER}/query` +
        `?objectIds=${encodeURIComponent(objectIds.join(","))}` +
        `&outFields=${encodeURIComponent(outFields)}` +
        `&returnGeometry=true` +
        `&outSR=${OUT_SR}` +
        `&returnZ=false&returnM=false` +
        `&f=geojson`;
      return await fetchJson(url);
    }

    function sanitizeForShapefile(fc) {
      // Remove null/invalid geometries
      fc.features = (fc.features || []).filter(f =>
        f && f.geometry && f.geometry.type && f.geometry.coordinates !== undefined && f.geometry.coordinates !== null
      );

      // DBF-safe properties (strings/numbers/booleans only)
      for (const f of fc.features) {
        const p = f.properties || {};
        for (const k of Object.keys(p)) {
          const v = p[k];
          if (v === null || v === undefined) continue;
          const t = typeof v;
          if (t === "string" || t === "number" || t === "boolean") continue;
          p[k] = (v instanceof Date) ? v.toISOString() : JSON.stringify(v);
        }
        f.properties = p;
      }
    }

    function isZipSignature(u8) {
      return u8 && u8.length >= 2 && u8[0] === 0x50 && u8[1] === 0x4B; // "PK"
    }

    async function zipToUint8Array(zipOut) {
      // IMPORTANT: @mapbox/shp-write zip() may return:
      // - a JSZip instance (preferred) -> has generateAsync
      // - a Uint8Array/ArrayBuffer/string depending on build/environment
      if (zipOut && typeof zipOut.generateAsync === "function") {
        return await zipOut.generateAsync({ type: "uint8array", compression: "DEFLATE" });
      }

      if (zipOut instanceof ArrayBuffer) return new Uint8Array(zipOut);

      if (zipOut && zipOut.buffer instanceof ArrayBuffer && typeof zipOut.byteLength === "number") {
        return new Uint8Array(zipOut.buffer, zipOut.byteOffset || 0, zipOut.byteLength);
      }

      if (typeof zipOut === "string") {
        // Treat as latin1 binary string
        const out = new Uint8Array(zipOut.length);
        for (let i = 0; i < zipOut.length; i++) out[i] = zipOut.charCodeAt(i) & 0xff;
        return out;
      }

      throw new Error(`Unexpected zip() return type: ${zipOut?.constructor?.name || typeof zipOut}`);
    }

    async function previewCount() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;
      setStatus(`Counting features for:\n"${incident}"\n\nFetching objectIds…`);

      const objectIds = await fetchObjectIds(where);
      setStatus(`"${incident}"\nFeature count: ${objectIds.length}`, "ok");
    }

    async function exportShapefile() {
      const incident = decodeURIComponent(incidentEl.value || "");
      if (!incident) return;

      exportBtn.disabled = true;
      previewBtn.disabled = true;

      try {
        if (!window.shpwrite) throw new Error("@mapbox/shp-write failed to load.");

        const layerInfo = await getLayerInfo();
        const pageSize = Number(layerInfo.maxRecordCount) || DEFAULT_FALLBACK_PAGE;
        const layerWkid = layerInfo?.extent?.spatialReference?.wkid ?? layerInfo?.sourceSpatialReference?.wkid;

        const where = `${INCIDENT_FIELD} = '${escapeSqlString(incident)}'`;

        setStatus(
          `Layer SR (reported): ${layerWkid ?? "unknown"}\n` +
          `Requesting outSR: ${OUT_SR}\n\n` +
          `Preparing export for:\n"${incident}"\n\nFetching objectIds…`
        );

        const objectIds = await fetchObjectIds(where);

        if (!objectIds.length) {
          setStatus(`No features found for:\n"${incident}"`, "warn");
          return;
        }

        if (objectIds.length > HARD_STOP_FEATURES) {
          setStatus(
            `Too many features for browser-only export.\n\n` +
            `Count: ${objectIds.length}\nLimit: ${HARD_STOP_FEATURES}`,
            "warn"
          );
          return;
        }

        setStatus(`Found ${objectIds.length} features.\nDownloading GeoJSON in batches of ${pageSize} (outSR=${OUT_SR})…`);

        const combined = { type: "FeatureCollection", features: [] };

        for (let i = 0; i < objectIds.length; i += pageSize) {
          const batch = objectIds.slice(i, i + pageSize);
          setStatus(`Downloading… ${Math.min(i + pageSize, objectIds.length)} / ${objectIds.length}`);
          const fc = await fetchGeoJsonByObjectIds(batch, "*");
          if (fc?.features?.length) combined.features.push(...fc.features);
        }

        setStatus(`Downloaded ${combined.features.length} features.\nSanitizing for shapefile…`);
        sanitizeForShapefile(combined);

        if (!combined.features.length) {
          setStatus(`No valid geometries returned for:\n"${incident}"`, "warn");
          return;
        }

        const base = safeBaseName(incident);

        setStatus(`Creating ZIP…`);
        const zipOut = shpwrite.zip(combined, {
          folder: base,
          types: { point: `${base}_pts`, polygon: `${base}_poly`, line: `${base}_line` }
        });

        const u8 = await zipToUint8Array(zipOut);

        const sig = isZipSignature(u8);
        setStatus(`ZIP bytes: ${u8.byteLength.toLocaleString()}\nSignature: ${sig ? "PK (valid)" : "NOT PK (invalid)"}`, sig ? "ok" : "danger");

        if (!sig) throw new Error("ZIP signature is not PK — exporter did not produce a real zip stream.");

        const blob = new Blob([u8], { type: "application/zip" });
        saveAs(blob, `${base}_NAD83_4269.zip`);

        setStatus(`Done.\nSaved: ${base}_NAD83_4269.zip`, "ok");
      } catch (err) {
        console.error(err);
        setStatus(`Error:\n${err.message || err}`, "danger");
      } finally {
        exportBtn.disabled = false;
        previewBtn.disabled = false;
      }
    }

    // Events
    filterEl.addEventListener('input', () => renderIncidents(filterEl.value));
    previewBtn.addEventListener('click', () => previewCount());
    exportBtn.addEventListener('click', () => exportShapefile());

    // Init
    loadIncidents().catch(err => setStatus(`Error loading incidents:\n${err.message || err}`, "danger"));
  </script>
</body>
</html>
